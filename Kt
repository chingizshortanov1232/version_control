# Что такое Git и зачем он нужен?
**Git** - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.
Создание репозитория
Теперь вы готовы к работе с Git локально на компьютере.

Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.

 #Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init
Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.

#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> +

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий>"
Cоздали свой первый репозиторий и заполнили его первым commit.
## Команды для работы с Git**cd folder_name** – перемещение в папку и из папки

**cd ..** – возвращение на 1 уровень назад

**new-item fail_name** – создание новых файлов в хранилище

**mkdir folder_name** – создание новых папок

**is** – отображение списка всех файлов, которые находятся в данной папке

**clear** - очищает терминал от прошлых команд

**git init** - инициализация репозитория

**git add "file_name"** - добавление файлу с названием "file_name" версионнности

**git add .** - добавление всем файлам в папке версионности

**git reset .** - снятие у всех файлов в папке версионности

**git reset "file_name"** - удаление у файла с названием "file_name" версионности

**git reset —hard HEAD~3** - безвозвратное удаление нескольких коммитов (в данном случае 3)

**git commit -m "commit_message"** - сохранение текущего состояния с комментариями

**git commit -am "commit_message"** - сохранение последующего коммита с комментарием (без использования команды**git add "file_name"**)

**git diff** - отображение разницы между текущим состоянием файла и его зафиксированным состоянием (команда используется, когда есть несколько зафиксированных состояний)

**git log** - вывод истории изменений (показ всех коммитов) в текущей ветке

**git log --graph** - вывод списка коммитов в виде дерева

**git log --onelina -- all** - вывод подробной истории репозитория с коммитами

**git checkout "hash_number"** - перемещение на коммит с хэшем "hash_number"

**git checkout master/main** - возвращение на последний коммит текущей ветки

**git branch** - вывод всех созданных веток, а также определение той ветки, на которой мы сейчас находимся

**git checkout branch_name** – переместиться на ветку, название которой указано в команде

**git checkout -b branch_name** – создать новую ветку и переместиться в неё

**git branch -d branch_name** – удалить слитую с основной ветку

**git branch -D branch_name** – удалить не слитую с основной ветку

**git merge branch_name** – слить в текущую ветку изменения из той ветки, название которой указано в команде

**git clone adress** - создание копии репозитория, который находится на сервисе GitHub, в нашем локальном репозитории

**git push** - протолкнуть всё, что мы сделали локально, куда-то на удалённый репозиторий. Если работаем на новой ветке, и с неё необходимо протолкнуть информацию, то используем команду**git push -u****git pull** - стянуть с удалённого репозитория все изменения

**git remote** - даём программе понять, что появился новый удалённый репозиторий

git fetch
Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Мы познакомились с ней в разделе Получение изменений из удалённого репозитория — Fetch и Pull главы 2 и продолжили знакомство в разделе Удалённые ветки главы 3.

Мы использовали эту команду в нескольких примерах из раздела Участие в проекте.

Мы использовали её для скачивания запросов на слияние (pull request) из других репозиториев в разделе Ссылки на запрос слияния главы 6, также мы рассмотрели использование git fetch для работы с упакованными репозиториями в разделе Создание пакетов главы 7.

Мы рассмотрели тонкую настройку git fetch в главе и Спецификации ссылок.

git pull
Команда git pull работает как комбинация команд git fetch и git merge, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

Мы познакомились с ней в разделе Получение изменений из удалённого репозитория — Fetch и Pull главы 2 и показали как узнать, какие изменения будут приняты в случае применения в разделе Просмотр удалённого репозитория главы 2.

Мы также увидели как она может оказаться полезной для разрешения сложностей при перемещении веток в разделе Меняя базу, меняй основание главы 3.

Мы показали как можно использовать только URL удалённого репозитория без сохранения его в списке удалённых репозиториев в разделе Извлечение удалённых веток главы 5.

И наконец мы показали как проверять криптографические подписи полученных коммитов, используя опцию --verify-signatures в разделе Подпись коммитов главы 7.

git push
Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

Мы познакомились с этой командой в разделе Отправка изменений в удалённый репозиторий (Push) главы 2. Там мы рассмотрели основы обновления веток в удалённом репозитории. В разделе Отправка изменений главы 3 мы подробнее познакомились с этой командой, а в разделе Отслеживание веток главы 3 мы узнали как настроить отслеживание веток для автоматической передачи на удалённый репозиторий. В разделе Удаление веток на удалённом сервере главы 3 мы использовали флаг --delete для удаления веток на сервере, используя git push.

На протяжении раздела Участие в проекте мы показали несколько примеров использования git push для совместной работы в нескольких удалённых репозиториях одновременно.

В разделе Публикация изменений подмодуля главы 7 мы использовали опцию --recurse-submodules чтобы удостовериться, что все подмодули будут опубликованы перед отправкой проекта на сервер, что может быть реально полезным при работе с репозиториями, содержащими подмодули.

В разделе Прочие хуки на стороне клиента главы 8 мы поговорили о триггере pre-push, который может быть выполнен перед отправкой данных, чтобы проверить возможность этой отправки.

Наконец, в разделе Спецификации ссылок для отправки данных на сервер главы 10 мы рассмотрели передачу данных с полным указанием передаваемых ссылок, вместо использования распространённых сокращений. Это может быть полезным если вы хотите очень точно указать, какими изменениями хотите поделиться.

git remote
Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например «origin», так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

Эта команда детально рассмотрена в разделе Работа с удалёнными репозиториями главы 2, включая вывод списка удалённых репозиториев, добавление новых, удаление или переименование существующих.

Она используется практически в каждой главе, но всегда в одном и том же виде: git remote add <имя> <URL>.

git archive
Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

Мы использовали git archive для создания тарбола (tar.gz файла) всего проекта для передачи по сети в разделе Подготовка релиза главы 5.

git submodule
Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.
